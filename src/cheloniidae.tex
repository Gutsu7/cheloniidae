\documentclass{article}
\usepackage{spencer}

\noindentpars

\title{Cheloniidae Turtle Graphics}
\author{Spencer Tipping}

\begin{document}
  \maketitle

  \tableofcontents

  \section{Introduction}
    \label{sec:introduction}

    Cheloniidae is a high-performance turtle graphics platform that is focused on generating antialiased, complex images. To this end, it has support for
    multiple turtles, turtle networks, 3D coordinate spaces, translucent lines, and optically-accurate projective rendering.

    A Cheloniidae scene is built by creating a drawing window and then adding turtles and other drawing objects to the window. Turtles are then driven by using
    a series of monadic invocations. This has the advantage that driving one turtle and driving multiple turtles can be achieved using the same syntax. (See
    section \ref{sec:turtle-monad})

    \begin{scalacode}
package cheloniidae

import java.awt._
import java.util._
    \end{scalacode}

  \section{Geometric Logic}
    \label{sec:geometric-logic}

    Before implementing a turtle it is necessary to define a library of geometric primitives. Vectors are the most prominent notion here. Nothing too special is
    happening; it's just a vector of three doubles.

    The other notion is that of a line segment. A basic line segment just consists of two vectors that delineate its endpoints, though later on we'll subclass
    it to add colors.

    \subsection{Vectors}
      \label{sec:vectors}

      Vectors are immutable. The only other unusual thing about them is the presence of the {\tt +*} operator, which stands for ``add-scaled.'' Since it takes
      two parameters, it cannot be used in an infix manner; thus, for instance, its invocation would look like this: {\tt x.+*(y, 2)}.

      \begin{scalacode}
case class Vector (x: Double, y: Double, z: Double) {
  def map (f: (Double, Double) => Double) (v: Vector) = v match {
    case Vector (vx, vy, vz) => Vector (f (x, vx), f (y, vy), f (z, vz))}

  def + (that: Vector) = this.map ((a: Double, b: Double) => a + b) (that)
  def - (that: Vector) = this.map ((a: Double, b: Double) => a - b) (that)
  def * (that: Vector) = this.map ((a: Double, b: Double) => a * b) (that)
  def / (that: Vector) = this.map ((a: Double, b: Double) => a / b) (that)

  def + (a: Double) = new Vector (x + a, y + a, z + a)
  def - (a: Double) = new Vector (x - a, y - a, z - a)
  def * (a: Double) = new Vector (x * a, y * a, z * a)
  def / (a: Double) = new Vector (x / a, y / a, z / a)

  def +* (that: Vector, x: Double) = this.map ((a: Double, b: Double) => a + b * x) (that)

  def dot (that: Vector) = that match {
    case Vector (vx, vy, vz) => x*vx + y*vy + z*vz}

  def cross (that: Vector) = that match {
    case Vector (vx, vy, vz) => Vector (y*vz - z*vy, z*vx - x*vz, x*vy - y*vx)}

  def proj (that: Vector) = that * (this dot that) / (that dot that)
  def orth (that: Vector) = this - this proj that

  def length = Math.sqrt (this dot this)

  def to (that: Vector, c: Color) = new LineSegment (this, that, c)

  override def toString = "<" + x.toString + ", " + y.toString + ", " + z.toString + ">"
}
      \end{scalacode}

    \subsection{Line segments}
      \label{sec:line-segments}

      Line segments, like vectors, are immutable. They provide some handy methods such as directional scaling, length and midpoint calculation, etc. One method
      of note is the V method, which concatenates two lines. This can be used to close a polygon, for instance. It has the property that two lines $A = (v_1,
      v_2)$ and $B = (v_3, v_4)$ combine to $A~V~B = (v_1, v_4)$.

      \begin{scalacode}
case class LineSegment (v1: Vector, v2: Vector, c: Color) {
  def midpoint = (v1 + v2) / 2.0
  def length   = (v1 - v2).length

  def <*> (x: Double) = new LineSegment (midpoint + (v1 - midpoint) * x, midpoint + (v2 - midpoint) * x, c)
  def  *> (x: Double) = new LineSegment (v1, midpoint + (v2 - midpoint) * x, c)
  def <*  (x: Double) = new LineSegment (midpoint + (v1 - midpoint) * x, v2, c)

  def * (x: Double) = v1 * (1.0 - x) + v2 * x

  def V (l: LineSegment) = l match {
    case LineSegment (lv1, lv2, _) => new LineSegment (v1, lv2, c)}
}
      \end{scalacode}

  \section{Turtle Monad}
    \label{sec:turtle-monad}

    A turtle is represented as a monad whose data structures are a positional vector, represented either by $p$ or by $\langle x, y, z \rangle$, and a
    directional vector, represented either by $d$ or by $\langle dx, dy, dz \rangle$. Operations performed on the turtle yield a new turtle and are expected to
    have side-effects on the turtle's drawing window. In addition to its geometric attributes, a turtle also has a color and a drawing window.

    \begin{scalacode}
case class Turtle (p: Vector, d: Vector, c: Color, l: LineReceiver) {
  def <<[T] (f: Turtle => T) = f (this)
}
    \end{scalacode}

    \subsection{Turtle networks}
      \label{sec:turtle-networks}

      Multiple turtles can be coordinated and can draw lines between each other. This is useful when constructing grids, for instance. There are several types
      of turtle networks, and they connect turtles in different ways.

      \subsubsection{Linear turtle network}
        \label{sec:linear-turtle-network}

        A linear turtle network is used when you have $n$ turtles and you wish to form an $n\times m$ grid. The idea is that at any point you can invoke the
        {\tt synchronize} operation on the network and each turtle will draw a line to its neighbor. Thus a standard use case might look something like this:

        \begin{verbatim}
val w = new TurtleDrawingWindow ()
val n = new LinearNetwork ()
w << n
val t1 = n.createTurtle ()
val t2 = t1 + new Vector (50, 0, 0)
n << fd(100) << synchronize << rt(10) << fd(100) << synchronize
    \subsection{Drawing primitives}
      \label{sec:drawing-primitives}

      A turtle wouldn't be of much use without some primitives to work with. These drawing primitives allow the turtle to render lines and change its direction.

      \begin{scalacode}
object Drawing {
  def changePosition (pprime: Vector) = (t: Turtle) => t match {
    case Turtle (p, d, c, l) => {w.addLineSegment (p, pprime, c)
                                 new Turtle (pprime, d, c, l)}}

  def changeDirection (dprime: Vector) = (t: Turtle) => t match {
    case Turtle (p, d, c, l) => new Turtle (p, dprime, c, l)}

  def fd (x: Double) = (t: Turtle) => t match {
    case Turtle (p, d, c, l) => changePosition (p + d * x) (t)}
}
      \end{scalacode}

  \section{Turtle Drawing Window}
    \label{sec:turtle-drawing-window}

    A turtle drawing window maintains a list of line segments generated by turtles and displays them onscreen. It also can generate a turtle with sensible
    defaults.

    \begin{scalacode}
class TurtleDrawingWindow extends Frame with LineReceiver {
}
    \end{scalacode}

% vim: set syntax=scalatex :
\end{document}
