\documentclass{article}
\usepackage{spencer}

\noindentpars

\title{Cheloniidae Turtle Graphics}
\author{Spencer Tipping}

\begin{document}
  \maketitle

  \tableofcontents

  \section{Introduction}
    \label{sec:introduction}

    Cheloniidae is a high-performance turtle graphics platform that is focused on generating antialiased, complex images. To this end, it has support for
    multiple turtles, turtle networks, 3D coordinate spaces, translucent lines, and optically-accurate projective rendering.

    A Cheloniidae scene is built by creating a drawing window and then adding turtles and other drawing objects to the window. Turtles are then driven by using
    a series of monadic invocations. This has the advantage that driving one turtle and driving multiple turtles can be achieved using the same syntax. (See
    section \ref{sec:turtle-monad})

    \begin{scalacode}
package cheloniidae
    \end{scalacode}

  \section{Geometric Logic}
    \label{sec:geometric-logic}

    Before implementing a turtle it is necessary to define a library of geometric primitives. Vectors are the most prominent notion here. Nothing too special is
    happening; it's just a vector of three doubles.

    The other notion is that of a line segment. A basic line segment just consists of two vectors that delineate its endpoints, though later on we'll subclass
    it to add colors.

    \subsection{Vectors}
      \label{sec:vectors}

      Vectors are immutable. The only other unusual thing about them is the presence of the {\tt +*} operator, which stands for ``add-scaled.'' Since it takes
      two parameters, it cannot be used in an infix manner; thus, for instance, its invocation would look like this: {\tt x.+*(y, 2)}.

      \begin{scalacode}
case class Vector (x: Double, y: Double, z: Double) {
  def map (f: (Double, Double) => Double) (v: Vector) = v match {
    case Vector (vx, vy, vz) => Vector (f (x, vx), f (y, vy), f (z, vz))}

  def + (that: Vector) = this.map ((a: Double, b: Double) => a + b) (that)
  def - (that: Vector) = this.map ((a: Double, b: Double) => a - b) (that)
  def * (that: Vector) = this.map ((a: Double, b: Double) => a * b) (that)
  def / (that: Vector) = this.map ((a: Double, b: Double) => a / b) (that)

  def + (a: Double) = new Vector (x + a, y + a, z + a)
  def - (a: Double) = new Vector (x - a, y - a, z - a)
  def * (a: Double) = new Vector (x * a, y * a, z * a)
  def / (a: Double) = new Vector (x / a, y / a, z / a)

  def +* (that: Vector, x: Double) = this.map ((a: Double, b: Double) => a + b * x) (that)

  def dot (that: Vector) = that match {
    case Vector (vx, vy, vz) => x*vx + y*vy + z*vz}

  def cross (that: Vector) = that match {
    case Vector (vx, vy, vz) => Vector (y*vz - z*vy, z*vx - x*vz, x*vy - y*vx)}

  def length = Math.sqrt (this dot this)

  def to (that: Vector) = new LineSegment (this, that)

  override def toString = "<" + x.toString + ", " + y.toString + ", " + z.toString + ">"
}
      \end{scalacode}

    \subsection{Line segments}
      \label{sec:line-segments}

      Line segments, like vectors, are immutable. They provide some handy methods such as directional scaling, length and midpoint calculation, etc. One method
      of note is the V method, which concatenates two lines. This can be used to close a polygon, for instance. It has the property that two lines $A = (v_1,
      v_2)$ and $B = (v_3, v_4)$ combine to $A~V~B = (v_1, v_4)$.

      \begin{scalacode}
case class LineSegment (v1: Vector, v2: Vector) {
  def midpoint = (v1 + v2) / 2.0
  def length   = (v1 - v2).length

  def <*> (x: Double) = new LineSegment (midpoint + (v1 - midpoint) * x, midpoint + (v2 - midpoint) * x)
  def  *> (x: Double) = new LineSegment (v1, midpoint + (v2 - midpoint) * x)
  def <*  (x: Double) = new LineSegment (midpoint + (v1 - midpoint) * x, v2)

  def V (l: LineSegment) = l match {
    case LineSegment (lv1, lv2) => new LineSegment (v1, lv2)}
}
      \end{scalacode}

  \section{Turtle Monad}
    \label{sec:turtle-monad}

    A turtle is represented as a monad whose data structures are a positional vector, represented either by $p$ or by $\langle x, y, z \rangle$, and a
    directional vector, represented either by $d$ or by $\langle dx, dy, dz \rangle$. Operations performed on the turtle yield a turtle-drawing monad that
    contains two parts. The first part is a list of line segments, if there are any, and the second part is the new state of the turtle.

    \begin{scalacode}
final case class Turtle (p: Vector, d: Vector) {
  private var e: Environment = null

  def do[T] (f: Turtle => T) = f (this)

  def >>= (f: (Vector, Vector) => (List[LineSegment], Vector, Vector)) = f (p, d)
}
    \end{scalacode}

% vim: set syntax=scalatex :
\end{document}
