\documentclass{article}
\usepackage{spencer}

\noindentpars

\title{Cheloniidae Turtle Graphics}
\author{Spencer Tipping}

\begin{document}
  \maketitle

  \tableofcontents

  \section{Introduction}
    \label{sec:introduction}

    Cheloniidae is a high-performance turtle graphics platform that is focused on generating antialiased, complex images. To this end, it has support for
    multiple turtles, turtle networks, 3D coordinate spaces, translucent lines, and optically-accurate projective rendering.

    A Cheloniidae scene is built by creating a drawing window and then adding turtles and other drawing objects to the window. Turtles are then driven by using
    a series of binary operators (see section \ref{sec:turtles}).

    \begin{scalacode}
object cheloniidae {

import java.awt.Color
import java.awt.Frame
    \end{scalacode}

  \section{Geometric Logic}
    \label{sec:geometric-logic}

    Before implementing a turtle it is necessary to define a library of geometric primitives. Vectors are the most prominent notion here. Nothing too special is
    happening; it's just a vector of three doubles.

    The other notion is that of a line segment. A basic line segment just consists of two vectors that delineate its endpoints, though later on we'll subclass
    it to add colors.

    \subsection{Vectors}
      \label{sec:vectors}

      Vectors are immutable. The only other unusual thing about them is the presence of the {\tt +*} operator, which stands for ``add-scaled.'' Since it takes
      two parameters, it cannot be used in an infix manner; thus, for instance, its invocation would look like this: {\tt x.+*(y, 2)}.

      \begin{scalacode}
case class Vector (x: Double, y: Double, z: Double) {
  def map (f: (Double, Double) => Double) (v: Vector) = v match {
    case Vector (vx, vy, vz) => Vector (f (x, vx), f (y, vy), f (z, vz))}

  def + (that: Vector) = this.map ((a: Double, b: Double) => a + b) (that)
  def - (that: Vector) = this.map ((a: Double, b: Double) => a - b) (that)
  def * (that: Vector) = this.map ((a: Double, b: Double) => a * b) (that)
  def / (that: Vector) = this.map ((a: Double, b: Double) => a / b) (that)

  def + (a: Double) = new Vector (x + a, y + a, z + a)
  def - (a: Double) = new Vector (x - a, y - a, z - a)
  def * (a: Double) = new Vector (x * a, y * a, z * a)
  def / (a: Double) = new Vector (x / a, y / a, z / a)

  def +* (that: Vector, x: Double) = this.map ((a: Double, b: Double) => a + b * x) (that)

  def dot (that: Vector) = that match {
    case Vector (vx, vy, vz) => x*vx + y*vy + z*vz}

  def cross (that: Vector) = that match {
    case Vector (vx, vy, vz) => Vector (y*vz - z*vy, z*vx - x*vz, x*vy - y*vx)}

  def proj (that: Vector) = that * (this dot that) / (that dot that)
  def orth (that: Vector) = this - this proj that

  def length = Math.sqrt (this dot this)

  def to (that: Vector, c: Color) = new LineSegment (this, that, c)
  def to (that: Vector)           = new LineSegment (this, that, null)

  override def toString = "<" + x.toString + ", " + y.toString + ", " + z.toString + ">"
}
      \end{scalacode}

    \subsection{Line segments}
      \label{sec:line-segments}

      Line segments, like vectors, are immutable. They provide some handy methods such as directional scaling, length and midpoint calculation, etc. One method
      of note is the V method, which concatenates two lines. This can be used to close a polygon, for instance. It has the property that two lines $A = (v_1,
      v_2)$ and $B = (v_3, v_4)$ combine to $A~V~B = (v_1, v_4)$.

      \begin{scalacode}
case class LineSegment (v1: Vector, v2: Vector, c: Color) {
  def midpoint = (v1 + v2) / 2.0
  def length   = (v1 - v2).length

  def  *> (x: Double) = new LineSegment (v1, midpoint + (v2 - midpoint) * x, c)
  def <*  (x: Double) = new LineSegment (midpoint + (v1 - midpoint) * x, v2, c)

  def * (x: Double) = v1 * (1.0 - x) + v2 * x

  def V (l: LineSegment) = l match {
    case LineSegment (lv1, lv2, _) => new LineSegment (v1, lv2, c)}
}
      \end{scalacode}

  \section{Turtles}
    \label{sec:turtles}

    Turtles are mutable data structures that support a basic set of commands. Most likely you won't use these commands directly; to operate a turtle you will
    probably want to instantiate a subclass of {\tt TurtleDriver}, which wraps the turtle with a more friendly interface. Particularly, it enables you to drive
    the turtle with a series of binary operators, so your code looks like this:

    \begin{verbatim}
val a = new AngularTurtleDriver (new GeometricTurtle ())
(new TurtleDrawingWindow () << a) setVisible true
4 times {a fd 100 rt 90}
    \end{verbatim}

    \subsection{Imperative control structures}
      \label{sec:imperative-control-structures}

      To iterate like Ruby, we can provide an implicit integer conversion. The resulting object supports methods such as {\tt times}, which encapsulate the
      iteration step.

      \begin{scalacode}
implicit def integer_to_iteration_container (x: Int) = IterationContainer (x)

case class IterationContainer (x: Int) {
  def times (what: Int => Unit) = {
    var i = 0
    while (i < x) {
      what (i)
      i += 1
    }
    x
  }

  def times (what: => Unit) = this times ((x: Int) => what)
}
      \end{scalacode}

    \subsection{Basic turtle interface}
      \label{sec:basic-turtle-interface}

      

  \section{Turtle Drawing Window}
    \label{sec:turtle-drawing-window}

    A turtle drawing window maintains a list of line segments generated by turtles and displays them onscreen. It also can generate a turtle with sensible
    defaults.

    \begin{scalacode}
class TurtleDrawingWindow extends Frame {
}
    \end{scalacode}
  
  \section{Closing}
    \label{sec:closing}

    \begin{scalacode}
} // object cheloniidae
    \end{scalacode}

% vim: set syntax=scalatex :
\end{document}
